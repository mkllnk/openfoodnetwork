# frozen_string_literal: true

require 'spec_helper'

RSpec.describe "/payment_gateways/taler/:id" do
  let(:shop) { create(:distributor_enterprise) }
  let(:taler) {
    Spree::PaymentMethod::Taler.create!(
      name: "Taler",
      environment: "test",
      distributors: [shop],
      preferred_backend_url: "https://backend.demo.taler.net/instances/sandbox",
      preferred_api_key: "sandbox",
    )
  }
  let(:order) { create(:order_ready_for_confirmation, payment_method: taler) }
  let(:payment) { order.payments.last }

  before do
    payment.update!(
      source: taler,
      payment_method: taler,
      # This is a Taler order id of a paid order on the test backend.
      # It may be gone when you try to re-record this test.
      # To create a new order, you need user interaction with a wallet.
      response_code: "2026.020-03R3ETNZZ0DVA",
      redirect_auth_url: "https://merchant.backend.where-we-paid.com",
    )
  end

  it "completes the order", :vcr do
    get payment_gateways_confirm_taler_path(payment_id: payment.id)
    expect(response).to redirect_to(order_path(order, order_token: order.token))

    payment.reload
    expect(payment.state).to eq "completed"
  end

  it "redirects if payment is marked as processing already" do
    payment.update!(state: "processing")

    allow_any_instance_of(Taler::Order)
      .to receive(:fetch).with("order_status").and_return("claimed")

    get payment_gateways_confirm_taler_path(payment_id: payment.id)
    expect(response).to redirect_to "/checkout/payment"

    payment.reload
    expect(payment.state).to eq "processing"

    order.reload
    expect(order.state).to eq "confirmation"
  end

  it "handles all variants going out of stock" do
    allow_any_instance_of(Taler::Order)
      .to receive(:fetch).with("order_status").and_return("paid")
    order.line_items[0].variant.on_hand = 0

    get payment_gateways_confirm_taler_path(payment_id: payment.id)
    expect(response).to redirect_to "/checkout/details"

    payment.reload
    expect(payment.state).to eq "completed"

    order.reload
    expect(order.state).to eq "confirmation"
  end
end
